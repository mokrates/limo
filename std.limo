;; limo.init
;; do it in limo!

(write "+std.limo")

;(setq _trace :t)

(setq defmacro 
      (macro (name args . body)
	(list 'setq name (list 'macro args (cons 'progn body)))))

(setq defun
      (macro (name args . body)
	(list 'setq name (list 'lambda args (cons 'progn body)))))

(defmacro assert (x)
  `(try
    ,`(if ,x :t 
	  ,`(throw ,`(list 'ASSERT_FAIL ,`(quote ,x))))
    ,`(throw ,`(list 'ASSERT_FAIL_WITH_EXCEPTION ,`(quote ,x) _exception))))

(defmacro asserteq (x y)
  `(assert ,`(deepeq ,x ,y)))

(defun reverse (l) ;; used by quasiquote
  (defun helper (l akku)
    (if l (helper (cdr l) (cons (car l) akku)) akku))
  (helper l ()))

(defun undyn (x)   ;; recursive! no dynamic version! (of course...)
  (cond ((and (consp x) x)  ;; cons and not empty
	 (cons (undyn (car x)) (undyn (cdr x))))
	(:t x)))

(defun deepeq (x y)
  (cond ((and (consp x) x)  ;; cons and not empty
	 (and (consp y)
	      y
	      (deepeq (car x) (car y))
	      (deepeq (cdr x) (cdr y))))
	(:t (eq x y))))
	 
(defmacro quasiquote (l) ; (using _callerenv)
   (defun helper (l akku)
     (cond ((not l) akku)
	   ((and (consp (car l)) 
		 (car l)  ;; not nil
		 (eq (caar l) 'comma))
	    (helper (cdr l) 
		    (cons (car (cdar l)) akku)))
	   ((and (consp (car l))
		 (car l)
		 (eq (caar l) 'splice))
	    (helper (cdr l) 
		    (helper (eval (car (cdar l)) _callerenv) akku)))
	   (:t (helper (cdr l) 
		       (cons (list 'quote (car l)) akku)))))
   (cons 'list (reverse (helper l ()))))

(defmacro limo-loop x
  `(progn
    ,`(defun recur ,(car x)
	,@(cddr x))
    ,`(recur ,@(cadr x))))

(defmacro loop x
  (defun lvals (args)
    (if args (cons (car args) (lvals (cddr args))) ()))
  (defun rvals (args)
    (if args (cons (cadr args) (rvals (cddr args))) ()))

  `(progn
    ,`(defun recur ,(lvals (car x))
	,@(cdr x))
    ,`(recur ,@(rvals (car x)))))

(defun dmap (f a)
  (defun helper (f a)
    (when a
	  (dcons (f (car a)) (helper f (cdr a)))))
  (helper f a))

(defun map (f a)
  (defun helper (f a)
    (when a
	  (cons (f (car a)) (helper f (cdr a)))))
  (helper f a))

(defun curry (f . args)
  (lambda x
    (apply f (append args x))))

(defun list-length (x)
  (loop (x x l 0)
	(if x (recur (cdr x) (+ 1 l)) l)))

(defun identity (x)
  x)

(defun comp fs
  (cond ((not fs) identity)
	((not (consp fs)) (write "(comp {fun}*)"))
	((not (cdr fs)) (car fs))
	(:t (lambda (x) ((car fs) ((apply comp 
					  (cdr fs)) 
				   x))))))

(defun dzipn x
  (when (and (apply andf (dmap consp x))
	     (apply andf x))
	(dcons (dmap car x)
	       (apply dzipn (dmap cdr x)))))

(defun dzip2 (a b)
  (when (and (consp a)
	     (consp b)
	     a b)
	(dcons (cons (car a) 
		     (car b))
	       (dzip2 (cdr a) 
		      (cdr b)))))

(defun not (x) 
  (if x () :t))

(setq  nil? not)

(defun caar (l) (car (car l)))
(defun cdar (l) (cdr (car l)))
(defun cadr (l) (car (cdr l)))
(defun cddr (l) (cdr (cdr l)))

(defmacro when (c . b)
  `(if ,c ,(cons 'progn b) ()))

(defmacro or l
  (if l 
      (list 'if (car l) 
	    (car l) 
	    (cons 'or (cdr l)))
      ()))

(defmacro and l
  (if l
      (list 'if (car l) 
	    (cons 'and (cdr l))
	    ())
      :t))

(defun andf l  ;; and as a function. not shorting
  (cond ((not l) :t)
	((not (consp l))
	 (error "ERROR: (andf foo bar)"))
	((car l)
	 (apply andf (cdr l)))
	(:t ())))

(defmacro cond l   ;; used by quasiquote
  (if l
      (list 'if (caar l) (car (cdar l))
	    (cons 'cond (cdr l)))
      ()))

(defmacro switch (s . items)
  (when items
	`(if ,`(eq ,s ,(caar items)) 
	      ,`(progn ,@(cdar items))
	      ,`(switch ,s ,@(cdr items)))))

(defun * os
  (reduce mpq_mul os))

(defun + os
  (reduce mpq_add os))

(defun - (start . os)
  (apply + (dcons start (dmap mpq_neg os))))

(defun / (start . os)
  (apply * (dcons start (dmap mpq_inv os))))

(setq < ltn)
(setq > gtn)

(defun fak (n)
  (defun helper (n akku)
    (if (eq n 1) 
	akku
	(helper (mpq_sub n 1) (mpq_mul akku n))))
  (helper n 1))

(defun nth (n l)
  (cond ((eq n 0) (car l))
	(:else (nth (mpq_sub n 1) (cdr l)))))

(defun range (start end step)  ;; recursive! with generator: drange.
  (if (eq start end)
      ()
      (cons start (range (mpq_add start step) end step))))

(defun drange (start end step)
  (if (eq start end)
      ()
      (dcons start (drange (mpq_add start step) end step))))

(defun lreduce (f l)   ;; fold l with f from left
  (loop
   (akku (car l) l (cdr l))
   (if l
       (recur (f akku (car l)) (cdr l))
       akku)))

(setq reduce lreduce)
	 
(defun dfilter (p l)    ;; filter list with predicate p
  (cond ((not l) l)
	((p (car l)) (dcons (car l) (dfilter p (cdr l))))
	(:else (dfilter p (cdr l)))))

(defun filter (p l)    ;; recursive
  (cond ((not l) l)
	((p (car l)) (cons (car l) (filter p (cdr l))))
	(:else (filter p (cdr l)))))

(defun append (l1 l2)  ;; recursive: with generator: dappend
  (if (not l1) l2
      (cons (car l1) (append (cdr l1) l2))))

(defun dappend (l1 l2)
  (if (not l1) l2
      (dcons (car l1) (dappend (cdr l1) l2))))

(defmacro for-each (x l . body)
  (setq it (gensym))
  `(progn
    ,`(defun recur ,`(,it)
	,`(when ,it 
		,`(setq ,x ,`(car ,it)) 
		,@body
		,`(recur ,`(cdr ,it))))
    ,`(recur ,l)))

(defmacro for-list (x l . body)
  (setq it (gensym))
  `(progn
    ,`(defun recur ,`(,x)
	,`(when ,x 
		,@body
		,`(recur ,`(cdr ,x))))
    ,`(recur ,l)))


(defun dqsort (lt l)  ;; seems to be less good than qsort. slower and deeper recursion (!)
  (defun ltx (x) (lt x (car l)))
  (if (not l)
      l
      (reduce append 
	      (list (dqsort lt (dfilter ltx (cdr l)))
		    (list (car l)) 
		    (dqsort lt (dfilter (comp not ltx) (cdr l)))))))

(defun qsort (lt l) 
  (defun ltx (x) (lt x (car l)))
  (if (not l)
      l
      (reduce append 
	      (list (qsort lt (filter ltx (cdr l)))
		    (list (car l))
		    (qsort lt (filter (comp not ltx) (cdr l)))))))

(defun make-symbol (s)
  (make-sym (string-concat "#:" s)))

(setq _ngensym 0)
(defun gensym x
  (setf _ngensym (+ 1 _ngensym))
  (if x 
      (make-symbol (string-concat (car x) (reprn _ngensym)))
      (make-symbol (string-concat "G" (reprn _ngensym)))))

(defmacro with-gensym (syms . body)
  `(progn ,@(map (lambda (x) `(setq ,x (gensym))) syms)
	  ,@ body))

(setq _builtin-string-concat string-concat)
(defun string-concat x
  (reduce _builtin-string-concat x))

(defmacro unify (l v)       ; destructuring assignment.
  (setq index (gensym))
  `(progn
    ,`(setq ,index ,v)
    ,@(loop (l l akku ())
	    (if l 
		(recur (cdr l) 
		       (append akku
			       `(,`(setq ,(car l) ,`(car ,index))
				 ,`(setq ,index ,`(cdr ,index)))))
		akku))))

(defun assoc (name l)
  (when l
	(if (eq name (caar l)) 
	    (car l)
	    (assoc name (cdr l)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; settings

(gcsetmax (* 1024 128))  ;; max 128mb ram for limo.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; not so cool stuff

(defun writelist (x)
  (when x
	(write (car x))
	(writelist (cdr x))))

(write "-std.limo")

; -*- scheme -*-

;; limo.init
;; do it in limo!

;;(setq _trace :t)

;; lisp style defmacro and defun (but with schemy param lists)

(setq defmacro 
      (macro (name args . body)
	(list setq name (list 'macro args (cons 'progn body)))))

(setq defun
      (macro (name args . body)
	 (list 'setq name (list 'lambda args (cons 'progn body)))))

;; scheme style 'define'
(defmacro define x
  (if (consp (car x)) ;; a function
      (list 'setq (caar x) (list 'lambda (cdar x) (cons 'progn (cdr x))))
      (list 'setq (car x) (cadr x))))

(defmacro assert (x)
  `(if ,x :t 
       ,`(throw ,`(list 'ASSERT_FAIL ,`(quote ,x)))))

(defmacro asserteq (x y)
  (try
   `(assert ,`(deepeq ,x ,y))
   `(write ,`(list 'asserteq_failed ,x ,y))))

(defun reverse (l) ;; used by quasiquote
  (defun helper (l akku)
    (if (consp l)
	(if l 
	    (helper (cdr l) (cons (car l) akku)) 
	    akku)
	(throw (cons "reverse takes a proper list" l))))
  (helper l ()))

(defun undyn (x)
  (defun helper (x akku)
    (cond ((not x) akku)
	  ((consp x)
	   (helper (cdr x) (cons (undyn (car x)) akku)))
	  (:else (throw (cons "undyn takes a proper list" x)))))
  (if (not (consp x))
      x
      (reverse (helper x ()))))

(defun deepeq (x y)
  (cond ((and (consp x) x)  ;; cons and not empty
	 (and (consp y)
	      y
	      (deepeq (car x) (car y))
	      (deepeq (cdr x) (cdr y))))
	(:t (eq x y))))

(defmacro quasiquote (l) ; (not using callerenv)
  (defun helper (l akku)
    (cond ((not l) akku)
	  ((and (consp (car l)) 
		(car l)  ;; not nil
		(eq (caar l) 'comma))
	   (helper (cdr l) 
		   (cons (list 'list (cadar l)) akku)))
	  ((and (consp (car l))
		(car l)
		(eq (caar l) 'splice))
	   (helper (cdr l) (cons (cadar l) akku)))
	  (:t (helper (cdr l) 
		      (cons (list 'list (list 'quote (car l))) akku)))))
  (cons 'append (reverse (helper l ()))))

'(defmacro quasiquote (l) ; (using _callerenv)
   (defun helper (l akku)
     (cond ((not l) akku)
	   ((and (consp (car l)) 
		 (car l)  ;; not nil
		 (eq (caar l) 'comma))
	    (helper (cdr l) 
		    (cons (car (cdar l)) akku)))
	   ((and (consp (car l))
		 (car l)
		 (eq (caar l) 'splice))
	    (helper (cdr l) 
		    (helper (eval (car (cdar l)) _callerenv) akku)))
	   (:t (helper (cdr l) 
		       (cons (list 'quote (car l)) akku)))))
   (cons 'list (reverse (helper l ()))))

(defmacro limo-loop x
  `(progn
    ,`(defun recur ,(car x)
	,@(cddr x))
    ,`(recur ,@(cadr x))))

(defmacro loop x
  (defun lvals (args)
    (if args (cons (car args) (lvals (cddr args))) ()))
  (defun rvals (args)
    (if args (cons (cadr args) (rvals (cddr args))) ()))

  `(progn
    ,`(defun recur ,(lvals (car x))
	,@(cdr x))
    ,`(recur ,@(rvals (car x)))))

(defun dmap (f a)
  (defun helper (f a)
    (when a
	  (dcons (f (car a)) (helper f (cdr a)))))
  (helper f a))

(defun map (f a)
  (defun helper (f a)
    (when a
	  (cons (f (car a)) (helper f (cdr a)))))
  (helper f a))

(defun curry (f . args)
  (lambda x
    (apply f (append args x))))

(defun list-length (x)
  (loop (x x l 0)
	(if x (recur (cdr x) (+ 1 l)) l)))

(defun identity (x) x)
(defun list x x)

(defun comp fs
  (cond ((not fs) identity)
	((not (consp fs)) (throw "(comp {fun}*)"))
	((not (cdr fs)) (car fs))
	(:t (lambda x ((car fs) (apply (apply comp 
					      (cdr fs))
				       x))))))

(defun dzipn x
  (when (and (apply andf (dmap consp x))
	     (apply andf x))
	(dcons (dmap car x)
	       (apply dzipn (dmap cdr x)))))

(defun dzip2 (a b)
  (when (and (consp a)
	     (consp b)
	     a b)
	(dcons (cons (car a) 
		     (car b))
	       (dzip2 (cdr a) 
		      (cdr b)))))

(defun not (x) 
  (if x () :t))

(defun caar (l) (car (car l)))
(defun cdar (l) (cdr (car l)))
(defun cadr (l) (car (cdr l)))
(defun cddr (l) (cdr (cdr l)))
(defun cadar (l) (car (cdr (car l))))

(defmacro when (c . b)
  `(if ,c ,(cons 'progn b) ()))

(defmacro or l
  (if l 
      (list 'if (car l) 
	    (car l) 
	    (cons 'or (cdr l)))
      ()))

(defmacro and l
  (if l
      (list 'if (car l) 
	    (cons 'and (cdr l))
	    ())
      :t))

(defun andf l  ;; and as a function. not shorting
  (cond ((not l) :t)
	((not (consp l))
	 (error "ERROR: (andf foo bar)"))
	((car l)
	 (apply andf (cdr l)))
	(:t ())))

(defmacro cond l   ;; used by quasiquote
  (if l
      (list 'if (caar l) (cons 'progn (apply list (cdar l)))
	    (cons 'cond (cdr l)))
      ()))

(defmacro switch (s . items)
  (when items
	`(if ,`(eq ,s ,(caar items)) 
	     ,`(progn ,@(cdar items))
	     ,`(switch ,s ,@(cdr items)))))

(defun * os
  (if os
      (reduce mpq_mul os)
      1))

(defun + os
  (if os
      (if (numberp (car os))
	  (reduce mpq_add os)
	  (apply string-concat os))
      0))

(defun - (start . os)
  (apply + (dcons start (dmap mpq_neg os))))

(defun / (start . os)
  (apply * (dcons start (dmap mpq_inv os))))

(setq < ltn)
(setq > gtn)
(setq = eq)
(defun <= (x y)
  (or (< x y) (= x y)))
(defun >= (x y)
  (or (< x y) (= x y)))
(setq != (comp not eq))


(defun fak (n)
  (defun helper (n akku)
    (if (eq n 1) 
	akku
	(helper (mpq_sub n 1) (mpq_mul akku n))))
  (helper n 1))

(defun nth (n l)
  (cond ((eq n 0) (car l))
	(:else (nth (mpq_sub n 1) (cdr l)))))

(defun range (start end step)  ;; recursive! with generator: drange.
  (if (eq start end)
      ()
      (cons start (range (mpq_add start step) end step))))

(defun drange (start end step)
  (if (eq start end)
      ()
      (dcons start (drange (mpq_add start step) end step))))

(defun lreduce (f l)   ;; fold l with f from left
  (defun recur (akku l)
    (if l
	(recur (f akku (car l)) (cdr l))
	akku))
  (recur (car l) (cdr l)))

(setq reduce lreduce)

(defun dfilter (p l)    ;; filter list with predicate p
  (cond ((not l) l)
	((p (car l)) (dcons (car l) (dfilter p (cdr l))))
	(:else (dfilter p (cdr l)))))

(defun filter (p l)    ;; recursive
  (cond ((not l) l)
	((p (car l)) (cons (car l) (filter p (cdr l))))
	(:else (filter p (cdr l)))))

(defun append l
  (defun helper (l1 l2)  ;; recursive: with generator: dappend
    (if (not l1) l2
	(cons (car l1) (helper (cdr l1) l2))))
  (reduce helper (cons () l)))

(defun dappend (l1 l2)
  (if (not l1) l2
      (dcons (car l1) (dappend (cdr l1) l2))))

(defmacro scope x
  `(,`(lambda () ,`(progn ,@x))))

(defmacro for-each (x l . body)
  (setq it (gensym))
  `(progn
    ,`(defun recur ,`(,it)
	,`(when ,it 
		,`(setq ,x ,`(car ,it)) 
		,@body
		,`(recur ,`(cdr ,it))))
    ,`(recur ,l)))

(defmacro for-list (x l . body)
  (setq it (gensym))
  `(progn
    ,`(defun recur ,`(,x)
	,`(when ,x 
		,@body
		,`(recur ,`(cdr ,x))))
    ,`(recur ,l)))


(defun dqsort (lt l)  ;; seems to be less good than qsort. slower and deeper recursion (!)
  (defun ltx (x) (lt x (car l)))
  (if (not l)
      l
      (reduce append 
	      (list (dqsort lt (dfilter ltx (cdr l)))
		    (list (car l)) 
		    (dqsort lt (dfilter (comp not ltx) (cdr l)))))))




(defun qsort (lt l) 
  (defun ltx (x) (lt x (car l)))
  (if (not l)
      l
      (reduce append 
	      (list (qsort lt (filter ltx (cdr l)))
		    (list (car l))
		    (qsort lt (filter (comp not ltx) (cdr l)))))))

(defun make-symbol (s)
  (make-sym (string-concat "#:" s)))

(setq _ngensym 0)
(defun gensym x
  (setf _ngensym (+ 1 _ngensym))
  (if x 
      (make-symbol (string-concat (car x) (reprn _ngensym)))
      (make-symbol (string-concat "G" (reprn _ngensym)))))

(defmacro with-gensym (syms . body)
  `(progn ,@(map (lambda (x) `(setq ,x (gensym))) syms)
	  ,@body))

(defmacro unify (l v)       ; destructuring assignment.
  (setq index (gensym))
  `(progn
    ,`(setq ,index ,v)
    ,@(loop (l l akku ())
	    (if l 
		(recur (cdr l) 
		       (append akku
			       `(,`(setq ,(car l) ,`(car ,index))
				 ,`(setq ,index ,`(cdr ,index)))))
		akku))
    ,`(unsetq ,index)))

(defmacro unifyf (l v)       ; destructuring assignment.
  (setq index (gensym))
  `(progn
    ,`(setq ,index ,v)
    ,@(loop (l l akku ())
	    (if l 
		(recur (cdr l) 
		       (append akku
			       `(,`(setf ,(car l) ,`(car ,index))
				 ,`(setf ,index ,`(cdr ,index)))))
		akku))
    ,`(unsetq ,index)))


(defun assoc (name l)
  (when l
	(if (eq name (caar l)) 
	    (car l)
	    (assoc name (cdr l)))))

(defun member (m l)
  (cond ((not l) ())
	((eq (car l) m) l)
	(:else (member m (cdr l)))))

(defmacro set (k v)
  `(setq ,(eval k) ,v))

(defun setnth (n l v)
  (if (eq n 0)
      (setcar l v)
      (setnth (- n 1) (cdr l) v)))

(setq _place-setters (make-dict))
(defmacro setplacef (k v)
  (cond ((consp k)
	 `(,(cdr (dict-get _place-setters (car k))) ,@(append (cdr k) (list v))))
	(:else `(setf ,k ,v))))

(defmacro setplace (k v)
  `(setplacef ,(eval k) ,v))

(defun register-place-setter (g s)
  (dict-set _place-setters g s))

(register-place-setter 'car 'setcar)
(register-place-setter 'cdr 'setcdr)
(register-place-setter 'dict-getvalue 'dict-set)

(defun dict-getvalue (d k)
  (cdr (dict-get d k)))

(setq true :t)
(setq false ())

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; settings

'(gcsetmax (* 1024 128))  ;; max 128mb ram for limo.
;(* 1 2 3)




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; not so cool stuff

(defun writelist (x)
  (when x
	(write (car x))
	(writelist (cdr x))))


; -*- scheme -*-

;; limo.init
;; do it in limo!

;;(setq _trace :t)

;; lisp style defmacro and defun (but with schemy param lists)

(setconstq defmacro 
	   (macro (name args . body)
	     (list setconstq name (list 'macro args (cons 'progn body)))))

(setconstq defun
	   (macro (name args . body)
	     (list 'setq name (list 'lambda args (cons 'progn body)))))

(setconstq defcfun
	   (macro (name args . body)
	     (list 'setq name (list 'lambda args (cons 'progn body)))))

;; scheme style 'define'
(defmacro define x
  (if (consp (car x)) ;; a function
      (list 'setq (caar x) (list 'lambda (cdar x) (cons 'progn (cdr x))))
      (list 'setq (car x) (cadr x))))

(defmacro assert (x)
  `(try
    ,`(if ,x :t 
	  ,`(throw ,`(list 'ASSERT_FAIL ,`(quote ,x))))
    ,`(throw ,`(list 'ASSERT_FAIL_WITH_EXCEPTION ,`(quote ,x) _exception))))

(defmacro asserteq (x y)
  `(assert ,`(deepeq ,x ,y)))

(defcfun reverse (l) ;; used by quasiquote
  (defun helper (l akku)
    (if l (helper (cdr l) (cons (car l) akku)) akku))
  (helper l ()))

(defcfun undyn (x)   ;; recursive! no dynamic version! (of course...)
  (cond ((and (consp x) x)  ;; cons and not empty
	 (cons (undyn (car x)) (undyn (cdr x))))
	(:t x)))

(defcfun deepeq (x y)
  (cond ((and (consp x) x)  ;; cons and not empty
	 (and (consp y)
	      y
	      (deepeq (car x) (car y))
	      (deepeq (cdr x) (cdr y))))
	(:t (eq x y))))

(defmacro quasiquote (l) ; (not using callerenv)
  (defcfun helper (l akku)
    (cond ((not l) akku)
	  ((and (consp (car l)) 
		(car l)  ;; not nil
		(eq (caar l) 'comma))
	   (helper (cdr l) 
		   (cons (list 'list (cadar l)) akku)))
	  ((and (consp (car l))
		(car l)
		(eq (caar l) 'splice))
	   (helper (cdr l) (cons (cadar l) akku)))
	  (:t (helper (cdr l) 
		      (cons (list 'list (list 'quote (car l))) akku)))))
  (cons 'append (reverse (helper l ()))))

'(defmacro quasiquote (l) ; (using _callerenv)
   (defun helper (l akku)
     (cond ((not l) akku)
	   ((and (consp (car l)) 
		 (car l)  ;; not nil
		 (eq (caar l) 'comma))
	    (helper (cdr l) 
		    (cons (car (cdar l)) akku)))
	   ((and (consp (car l))
		 (car l)
		 (eq (caar l) 'splice))
	    (helper (cdr l) 
		    (helper (eval (car (cdar l)) _callerenv) akku)))
	   (:t (helper (cdr l) 
		       (cons (list 'quote (car l)) akku)))))
   (cons 'list (reverse (helper l ()))))

(defmacro limo-loop x
  `(progn
    ,`(defun recur ,(car x)
	,@(cddr x))
    ,`(recur ,@(cadr x))))

(defmacro loop x
  (defcfun lvals (args)
    (if args (cons (car args) (lvals (cddr args))) ()))
  (defcfun rvals (args)
    (if args (cons (cadr args) (rvals (cddr args))) ()))

  `(progn
    ,`(defun recur ,(lvals (car x))
	,@(cdr x))
    ,`(recur ,@(rvals (car x)))))

(defcfun dmap (f a)
  (defcfun helper (f a)
    (when a
	  (dcons (f (car a)) (helper f (cdr a)))))
  (helper f a))

(defcfun map (f a)
  (defcfun helper (f a)
    (when a
	  (cons (f (car a)) (helper f (cdr a)))))
  (helper f a))

(defcfun curry (f . args)
  (lambda x
    (apply f (append args x))))

(defcfun list-length (x)
  (loop (x x l 0)
	(if x (recur (cdr x) (+ 1 l)) l)))

(defcfun identity (x) x)
(defcfun list x x)

(defcfun comp fs
  (cond ((not fs) identity)
	((not (consp fs)) (throw "(comp {fun}*)"))
	((not (cdr fs)) (car fs))
	(:t (lambda x ((car fs) (apply (apply comp 
					      (cdr fs))
				       x))))))

(defcfun dzipn x
  (when (and (apply andf (dmap consp x))
	     (apply andf x))
	(dcons (dmap car x)
	       (apply dzipn (dmap cdr x)))))

(defcfun dzip2 (a b)
  (when (and (consp a)
	     (consp b)
	     a b)
	(dcons (cons (car a) 
		     (car b))
	       (dzip2 (cdr a) 
		      (cdr b)))))

(defcfun not (x) 
  (if x () :t))

(defcfun caar (l) (car (car l)))
(defcfun cdar (l) (cdr (car l)))
(defcfun cadr (l) (car (cdr l)))
(defcfun cddr (l) (cdr (cdr l)))
(defcfun cadar (l) (car (cdr (car l))))

(defmacro when (c . b)
  `(if ,c ,(cons 'progn b) ()))

(defmacro or l
  (if l 
      (list 'if (car l) 
	    (car l) 
	    (cons 'or (cdr l)))
      ()))

(defmacro and l
  (if l
      (list 'if (car l) 
	    (cons 'and (cdr l))
	    ())
      :t))

(defcfun andf l  ;; and as a function. not shorting
  (cond ((not l) :t)
	((not (consp l))
	 (error "ERROR: (andf foo bar)"))
	((car l)
	 (apply andf (cdr l)))
	(:t ())))

(defmacro cond l   ;; used by quasiquote
  (if l
      (list 'if (caar l) (car (cdar l))
	    (cons 'cond (cdr l)))
      ()))

(defmacro switch (s . items)
  (when items
	`(if ,`(eq ,s ,(caar items)) 
	     ,`(progn ,@(cdar items))
	     ,`(switch ,s ,@(cdr items)))))

(defcfun * os
  (if os
      (reduce mpq_mul os)
      1))

(defcfun + os
  (if os
      (if (numberp (car os))
	  (reduce mpq_add os)
	  (apply string-concat os))
      0))

(defcfun - (start . os)
  (apply + (dcons start (dmap mpq_neg os))))

(defcfun / (start . os)
  (apply * (dcons start (dmap mpq_inv os))))

(setconstq < ltn)
(setconstq > gtn)
(setconstq = eq)
(defcfun <= (x y)
  (or (< x y) (= x y)))
(defcfun >= (x y)
  (or (< x y) (= x y)))
(setconstq != (comp not eq))


(defcfun fak (n)
  (defun helper (n akku)
    (if (eq n 1) 
	akku
	(helper (mpq_sub n 1) (mpq_mul akku n))))
  (helper n 1))

(defcfun nth (n l)
  (cond ((eq n 0) (car l))
	(:else (nth (mpq_sub n 1) (cdr l)))))

(defcfun range (start end step)  ;; recursive! with generator: drange.
  (if (eq start end)
      ()
      (cons start (range (mpq_add start step) end step))))

(defcfun drange (start end step)
  (if (eq start end)
      ()
      (dcons start (drange (mpq_add start step) end step))))

(defcfun lreduce (f l)   ;; fold l with f from left
  (defun recur (akku l)
    (if l
	(recur (f akku (car l)) (cdr l))
	akku))
  (recur (car l) (cdr l)))

(setconstq reduce lreduce)

(defcfun dfilter (p l)    ;; filter list with predicate p
  (cond ((not l) l)
	((p (car l)) (dcons (car l) (dfilter p (cdr l))))
	(:else (dfilter p (cdr l)))))

(defcfun filter (p l)    ;; recursive
  (cond ((not l) l)
	((p (car l)) (cons (car l) (filter p (cdr l))))
	(:else (filter p (cdr l)))))

(defcfun append l
  (defcfun helper (l1 l2)  ;; recursive: with generator: dappend
    (if (not l1) l2
	(cons (car l1) (helper (cdr l1) l2))))
  (reduce helper (cons () l)))




(defcfun dappend (l1 l2)
  (if (not l1) l2
      (dcons (car l1) (dappend (cdr l1) l2))))

(defmacro for-each (x l . body)
  (setq it (gensym))
  `(progn
    ,`(defun recur ,`(,it)
	,`(when ,it 
		,`(setq ,x ,`(car ,it)) 
		,@body
		,`(recur ,`(cdr ,it))))
    ,`(recur ,l)))

(defmacro for-list (x l . body)
  (setq it (gensym))
  `(progn
    ,`(defun recur ,`(,x)
	,`(when ,x 
		,@body
		,`(recur ,`(cdr ,x))))
    ,`(recur ,l)))


(defcfun dqsort (lt l)  ;; seems to be less good than qsort. slower and deeper recursion (!)
  (defun ltx (x) (lt x (car l)))
  (if (not l)
      l
      (reduce append 
	      (list (dqsort lt (dfilter ltx (cdr l)))
		    (list (car l)) 
		    (dqsort lt (dfilter (comp not ltx) (cdr l)))))))




(defcfun qsort (lt l) 
  (defun ltx (x) (lt x (car l)))
  (if (not l)
      l
      (reduce append 
	      (list (qsort lt (filter ltx (cdr l)))
		    (list (car l))
		    (qsort lt (filter (comp not ltx) (cdr l)))))))

(defcfun make-symbol (s)
  (make-sym (string-concat "#:" s)))

(setq _ngensym 0)
(defcfun gensym x
  (setf _ngensym (+ 1 _ngensym))
  (if x 
      (make-symbol (string-concat (car x) (reprn _ngensym)))
      (make-symbol (string-concat "G" (reprn _ngensym)))))

(defmacro with-gensym (syms . body)
  `(progn ,@(map (lambda (x) `(setq ,x (gensym))) syms)
	  ,@body))

(defmacro unify (l v)       ; destructuring assignment.
  (setq index (gensym))
  `(progn
    ,`(setq ,index ,v)
    ,@(loop (l l akku ())
	    (if l 
		(recur (cdr l) 
		       (append akku
			       `(,`(setq ,(car l) ,`(car ,index))
				 ,`(setq ,index ,`(cdr ,index)))))
		akku))
    ,`(unsetq ,index)))

(defmacro unifyf (l v)       ; destructuring assignment.
  (setq index (gensym))
  `(progn
    ,`(setq ,index ,v)
    ,@(loop (l l akku ())
	    (if l 
		(recur (cdr l) 
		       (append akku
			       `(,`(setf ,(car l) ,`(car ,index))
				 ,`(setf ,index ,`(cdr ,index)))))
		akku))
    ,`(unsetq ,index)))


(defcfun assoc (name l)
  (when l
	(if (eq name (caar l)) 
	    (car l)
	    (assoc name (cdr l)))))

(defcfun member (m l)
  (cond ((not l) ())
	((eq (car l) m) l)
	(:else (member m (cdr l)))))

(defmacro scope x
  `(,`(lambda () ,`(progn ,@x))))

(defmacro set (k v)
  `(setq ,(eval k) ,v))

(defcfun setnth (n l v)
  (if (eq n 0)
      (setcar l v)
      (setnth (- n 1) (cdr l) v)))

(setq _place-setters (make-dict))
(defmacro setplacef (k v)
  (cond ((consp k)
	 `(,(cdr (dict-get _place-setters (car k))) ,@(append (cdr k) (list v))))
	(:else `(setf ,k ,v))))

(defmacro setplace (k v)
  `(setplacef ,(eval k) ,v))

(defcfun register-place-setter (g s)
  (dict-set _place-setters g s))

(register-place-setter 'car 'setcar)
(register-place-setter 'cdr 'setcdr)
(register-place-setter 'dict-getvalue 'dict-set)

(defcfun dict-getvalue (d k)
  (cdr (dict-get d k)))

(setconstq true :t)
(setconstq false ())

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; settings

'(gcsetmax (* 1024 128))  ;; max 128mb ram for limo.
;(* 1 2 3)




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; not so cool stuff

(defun writelist (x)
  (when x
	(write (car x))
	(writelist (cdr x))))


;;;;;;;;; threading ;;;;;;;;;
;; classes interface ;;;;

(mod-load "threading")

(defclass thread ()
  (defmethod init (self fun)
    (setmember [self . _fun] fun))
  (defmethod run (self)
    (setmember [self . _thread] ([_threading . thread-create] [self . _fun]))
    self)
  (defmethod join (self)
    ([_threading . thread-join] [self . _thread])))

(defclass mutex ()
  (defmethod init (self)
    (setmember [self . _mutex] ([_threading . mutex-create])))
  (defmethod lock (self)
    ([_threading . mutex-lock] [self . _mutex]))
  (defmethod unlock (self)
    ([_threading . mutex-unlock] [self . _mutex]))
  (defmethod trylock (self)
    ([_threading . mutex-trylock] [self . _mutex])))

(defclass condition-lock ()
  (defmethod init (self)
    (setmember [self . _cond] ([_threading . cond-create])))
  (defmethod wait (self mutex)
    ([_threading . cond-wait] [self . _cond] [mutex . _mutex]))
  (defmethod signal (self)
    ([_threading . cond-signal] [self . _cond]))
  (defmethod broadcast (self)
    ([_threading . cond-broadcast] [self . _cond])))

;;;;;;; cool stuff ;;;;;;;
(defmacro synchronized (mut . body)
  `(finally ,`(progn ,`[,mut lock] ,@body) ,`[,mut unlock]))

;;;; queue-lock
;; a FIFO for thread-communication
;; attention: you can get race-conditions if you use HAS-NEXT and GET
;; use your own end-marker, or if that doesn't work GET-OR-END with a marker


(defclass queue-lock ()
  (defmethod init (self)
    (setmember [self . _mutex] (new mutex))
    (setmember [self . _cond] (new condition-lock))
    (setmember [self . _queue] (cons () ()))
    (setmember [self . _getnext] [self . _queue])
    (setmember [self . _putnext] [self . _queue])
    (setmember [self . _finish] nil))
  (defmethod finish (self)
    (synchronized [self . _mutex]
      (setmember [self . _finish] :t)
      [[self . _cond] broadcast]))
  (defmethod has-next (self)
    (synchronized [self . _mutex]
      (while
       (and (eq [self . _putnext] [self . _getnext])
	    (not [self . _finish]))
       [[self . _cond] wait [self . _mutex]])
      (if (eq [self . _putnext] [self . _getnext])
	  (not [self . _finish])
	  :t)))
  (defmethod put (self item)
    (synchronized [self . _mutex]
      (setcar [self . _putnext] item)
      (setcdr [self . _putnext] (cons () ()))
      (setmember [self . _putnext] (cdr [self . _putnext]))
      [[self . _cond] broadcast]))
  (defmethod get-or-end (self end-marker)
    (synchronized [self . _mutex]
      (while
       (and (eq [self . _putnext] [self . _getnext])
	    (not [self . _finish]))
       [[self . _cond] wait [self . _mutex]])
      (if (and (eq [self . _putnext] [self . _getnext])
	       [self . _finish])
	  end-marker
	  (progn
	   (setq ret (car [self . _getnext]))
	   (setmember [self . _getnext] (cdr [self . _getnext]))
	   ret))))
  (defmethod get (self)
    (synchronized [self . _mutex]
      (while (eq [self . _putnext] [self . _getnext])
	     [[self . _cond] wait [self . _mutex]])
      (setq ret (car [self . _getnext]))
      (setmember [self . _getnext] (cdr [self . _getnext]))
      ret)))

(defun parallel-iterator (fun)
  (setq end-marker (gensym))
  (setq queue (new queue-lock))
  (defun writer-fun ()
    (for-each item (fun)
      [queue put item])
    [queue put end-marker])
  (setq writer-thread (new thread writer-fun))
  (defun reader-fun ()
    (setq res [queue get])
    (if (eq res end-marker)
	(progn
	 [writer-thread join]
	 ())
	(dcons res (reader-fun))))
  [writer-thread run]
  (reader-fun))

(defhelp parallel-iterator "
  FUNCTION parallel-iterator
(parallel-iterator fun)
-> <dynamic list>

example:
(for-each x (PARALLEL-ITERATOR (lambda () (drange 1 4 1))) (write x))
1
2
3
-> ()
")

(defun pmap (nworker fun xs)
  (setq queue (new queue-lock))
  (defun wfun ()
    (when (setq package [queue get-or-end ()])
      (setcar package ((car package)))
      (wfun)))
  (setq workers (map1 (lambda (x) [(new thread wfun x) run]) (drange 0 nworker 1)))
  (setq packages (map1 (lambda (x) (lambda () (fun x))) xs))
  (for-list p packages
    [queue put p])
  [queue finish]
  (for-each w workers
    [w join])
  packages)

(defhelp pmap "
  FUNCTION pmap
(pmap nworker fun xs)
Like map1, applies <fun> to <xs> and returns new list.
Unlike map1, pmap spreads the work to <nworker> threads.
Because of this, <fun> has to be threadsafe
")

; -*- scheme -*-

;; := is 'setf'-like
;; =  is 'setq'-like
;; [a,b] =  ... is destructuring
;; [a,b] := ... is destructuring too
;; for destructuring the lval MUST be LITERAL limpy-list, limo-lists don't work
;;   that is because if the lval is car(l) == (car l) there should setplacef be used,
;;   but the macro cannot differentiate between limo-lists and limpy-lists

;; a      = ...  limpy-assignq
;; [a,b]  = ...  limpy-assignq

;; [a,b] := ...  limpy-unifyf

;; a     := ...  limpy-assignf (setplacef)
;; a.b   := ...  limpy-assignf (setplacef)
;; a[b]  := ...  limpy-assignf (setplacef)

(defmacro limpy-assignq (a b)
  (if (consp a)
      `(unify ,a ,b)
      `(setq ,a ,b)))

(defmacro limpy-unifyf (a b)
  `(unifyf ,a ,b))

(defmacro limpy-assignf (a b)
  `(setplacef ,a ,b))

(defmacro limpy-defun (name params . body)
  `(setq ,name ,`(lambda ,params ,`(block _return ,`(progn ,@body)))))

(defmacro return x
  (if x
      `(return-from _return ,(car x))
      `(return-from _return)))

(defmacro while (condition . body)
  (with-gensym (fun)
	       `(block _break
		       ,`(progn
			  ,`(defun ,fun ()
			      ,`(if ,condition
				    ,`(progn ,`(block _continue
						      ,`(progn
							 ,@body))
					     ,`(,fun))
				    ()))
			  ,`(,fun)))))

(defmacro break x
  (if x
      `(return-from _break ,(car x))
      `(return-from _break)))

(defmacro continue x
  (if x
      `(return-from _continue ,(car x))
      `(return-from _continue)))


;; %[ x for y in z ] => limpy-parser sets thecons == cons
;; %( x for y in z ) => limpy-parser sets thecons == dcons
(defmacro limpy-gen (thecons compound lval li)
  (with-gensym (f args)
	       `(scope 
		 ,`(defun ,f ,`(,args)
		     ,`(when ,args 
			     ,`(limpy-assignq ,lval 
					      ,`(car ,args))
			     ,`(,thecons ,compound 
					 ,`(,f ,`(cdr ,args)))))
		 ,`(,f ,li))))

;; %[ x for y in z if c ]
;; %( x for y in z if c )
(defmacro limpy-gen-cond (thecons compound lval li condition)
  (with-gensym (args)
	       `(limpy-gen ,thecons 
			   ,compound 
			   ,lval 
			   ,`(dfilter ,`(lambda ,`(,args) 
					  ,`(progn
					     ,`(limpy-assignq ,lval ,args)
					     ,condition)) ,li))))

(defcfun limpy-getindex (c i)
  (cond ((consp c)
	 (nth i c))
	((dictp c)
	 (dict-getvalue c i))
	((stringp c)
	 (string-nth c i))
	(:else (throw "LIMPY-GETINDEX: Don't know how to use this Type"))))

(defcfun limpy-setindex (c i v)
  (cond ((consp c)
	 (setnth i c v))
	((dictp c)
	 (dict-set c i v))
	(:else (throw "LIMPY-SETINDEX: Don't know how to use this Type"))))

(register-place-setter 'limpy-getindex 'limpy-setindex)

;; for use by limpy programs

(defmacro var (x)  ;; declare a variable
  `(setq ,x ()))


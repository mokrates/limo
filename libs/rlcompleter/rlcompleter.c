#include <stdio.h>
#include <readline/readline.h>
#include <limo.h>

#define INSBUILTIN(f, name) setq(env, make_sym(name), make_builtin(f))

limo_data *sym_rlcompleter;
limo_data *ld_rlcomplete_rlcompleter;

static char **disp_matches=NULL;
static int disp_matches_len;
static void rlcompleter_disp_matches(char **matches, int len, int max)
{
  // so we ignore the arguments and display our own matches generated by rlcompleter_gen
  int i,x;
  max=0;
  for (max=0, i=1; i<=disp_matches_len; ++i) {
    x=strlen(disp_matches[i]);
    if (x > max) max=x;
  }
  rl_display_match_list(disp_matches, disp_matches_len, max);
  rl_forced_update_display();
}

static char *rlcompleter_gen(const char *text, int state) 
{
  static limo_data *lookup_list, *llcur;
  char *res;
  int i;

  if (!state) {
    lookup_list = eval(make_cons(ld_rlcomplete_rlcompleter, make_cons(make_string(text), nil)), globalenv);
    disp_matches_len = list_length(lookup_list);

    //if (disp_matches) free(disp_matches);
    disp_matches = GC_malloc((disp_matches_len + 2)* sizeof (char *));
    for (i=1, llcur = lookup_list;
	 !is_nil(llcur);
	 ++i, llcur=CDR(llcur))
      disp_matches[i] = CAR(CDR(CAR(llcur)))->d_string;
  }
  disp_matches[i]=NULL;
  
  while (!is_nil(lookup_list)) {
    res = (char *)malloc(strlen(CAR(CAR(lookup_list))->d_string)+1); // yes, malloc
    strcpy(res, CAR(CAR(lookup_list))->d_string);
    rl_completion_suppress_append = 1;  // just append space in completion function
    lookup_list= CDR(lookup_list);
    return res;
  }
  return NULL;
}

BUILTIN(builtin_set_rlcompleter)
{
  limo_data *ldrlc, *old_ldrlc, *old_break_characters;
  REQUIRE_ARGC("RLCOMPLETER-SET", 1);

  limo_rl_inited = 1;
  if (rl_completion_entry_function == rlcompleter_gen)
    old_ldrlc = make_cons(ld_rlcomplete_rlcompleter,
			  make_string(rl_basic_word_break_characters));
  else
    old_ldrlc = make_cons(make_special(sym_rlcompleter,
				       rl_completion_entry_function),
			  make_string(rl_basic_word_break_characters));
  
  ldrlc = eval(FIRST_ARG, env);

  REQUIRE_TYPE("RL-COMPLETER", ldrlc, limo_TYPE_CONS);
  REQUIRE_TYPE("RL-COMPLETER", CDR(ldrlc), limo_TYPE_STRING);

  old_break_characters = make_string(rl_completer_word_break_characters ? rl_completer_word_break_characters : "");
  rl_completer_word_break_characters = CDR(ldrlc)->d_string;
  if (CAR(ldrlc)->type == limo_TYPE_SPECIAL)
    rl_completion_entry_function = get_special(CAR(ldrlc), sym_rlcompleter);
  else {
    rl_completion_entry_function = rlcompleter_gen;
    rl_completion_display_matches_hook = rlcompleter_disp_matches;
    ld_rlcomplete_rlcompleter = CAR(ldrlc);
  }

  return make_cons(old_ldrlc, old_break_characters);
}

void limo_init_rlcompleter(limo_data *env)
{
  sym_rlcompleter = make_sym("RLCOMPLETER");
  INSBUILTIN(builtin_set_rlcompleter, "SET-RLCOMPLETER");
}
